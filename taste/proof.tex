\documentclass[10pt, a4paper]{article}
\usepackage{color}
\usepackage[procnames]{listings}
\usepackage[draft]{todonotes}   % notes showed
\usepackage{setspace}
\usepackage{tabularx}
%\usepackage[pdftoolbar=false, colorlinks=false, urlcolor=blue]{hyperref}

\addtolength{\oddsidemargin}{-.4in}
\addtolength{\evensidemargin}{-.4in}
\addtolength{\topmargin}{-0.6in}
\addtolength{\textwidth}{0.83in}
\addtolength{\textheight}{.6in}

\renewcommand{\baselinestretch}{1.3}

\begin{document}
\title{An Exercise in Assigning Meaning to a Python Program}
\author{M. Devi Prasad\vspace*{1.5mm}\\\texttt{dp@vlabs.ac.in}\\\texttt{deviprasad.m@iiit.ac.in},}
\date{}
\maketitle

\definecolor{keywords}{RGB}{0, 0, 255}
\definecolor{comments}{RGB}{0, 0, 113}
\definecolor{red}{RGB}{160, 0, 0}
\definecolor{green}{RGB}{0, 150, 0}
\definecolor{lightgreen}{RGB}{220, 230, 140}
\definecolor{lightorange}{RGB}{249, 150, 107}
\definecolor{lightbrown}{RGB}{249, 203, 156}
\definecolor{black}{RGB}{0, 0, 0}
\definecolor{background}{RGB}{235, 235, 235}
\definecolor{gray}{RGB}{235, 235, 235}

\section{Introduction}
In this article we show the application of simple yet effective ideas of Computing Science to understand the behavior of a Python program. The motivation is to apply a small number of ``pure" ideas of Computing Science to the ``impure" settings of real world (Python) programs with the hope that this exercise yields useful insights.

In what follows, we employ basic ideas of first-order logic to track the execution state of our Python program. In so doing, we will discover a bug in our program. Further, we will clarify one aspect of Python's iterator mechanism that appears to provide a stream-like interface to external files. Our attempt to express, in logical terms, the meaning of file iterators reveals that all iterators of an underlying file share the same state. We have found that this invariably surprises programmers whose intuitions are shaped by iterators for in-built sequence types of Python. While passing we would like to mention that the official documentation of Python language (and its libraries) do not state this fact.

The primary audience of this article includes students and programmers to whom we wish to impress the fact that the techniques used in this exercise may be easily practiced by novices, and with a little practice, can be used as an effective tool to guide the creation of test cases. It is also useful to recognize that these very techniques may be used to formulate program assertions.  

%In our opinion, impurities and difficulties in reasoning about the behavior of a program arise because of not-so-well-structured control flow, assignment statements, file I/O and assumptions about the well-formedness of the inputs. 

%Our goal is not to be scholarly and pedantic. On the contrary, our goal is to develop an appreciation for practicing some form of rigor, albeit in slightly diluted, and to discover for oneself that one can develop comprehensive test cases and assertions as an \emph{after thought}, having written the program and after having bitten by an embarrassing defect! Even if we do not succeed in designing correct programs ground up, we could take solace in the fact that we could apply simple ideas to develop good test cases and insert educated assertion within our programs. We would like our students to derive intellectual satisfaction in using semi-formal reasoning skills to increase their own confidence in the software they would eventually build!

\section{The Problem Statement}
We intend to assign meaning to a Python program that parses text files generated by running the \texttt{set} command under Linux (``bash") shell. Therefore, it is essential to understand the structure of the input to our program. But first, we shall see the actual command and the input text creation step:
{\setstretch{1.3}\lstset{language=bash, numbers=none,
    basicstyle=\ttfamily\small,
    showstringspaces=false,
    backgroundcolor=\color{gray}}
\begin{lstlisting}
$ set > env.txt
\end{lstlisting}}

\noindent Note that the output of the \texttt{set} command is redirected to a text file named \texttt{env.txt}. When the command executes successfully, this file contains a series of key-value pairs representing the environment variables active in the context of the currently running shell. Each line in the text file contains one key-value pair. 

In addition to key-value pairs, the text file contains a series of procedure definitions. A procedure definition consists of a name followed by an optional pair of braces (``(" and ``)"), followed by a block of statements. A statement block is enclosed within a pair of matching curly brackets (``\{" \ and \ ``\}"). It contains a sequence of statements (or shell commands). The open and close curly brackets appear on separate lines with no other lexical token either preceding them or following them (other than the ``invisible" newline character!). Here is a sample definition to help us visualize the typical form of a function:

{\setstretch{1.3}\lstset{language=bash, numbers=none,
    basicstyle=\ttfamily\small,
    showstringspaces=false,
    backgroundcolor=\color{background}}
\begin{lstlisting}
BASH=/bin/bash
BASH_ARGC=()
CHROME_DEVEL_SANDBOX=/usr/local/sbin/chrome-devel-sandbox
COLORTERM=gnome-terminal
COLUMNS=76
__git_log_pretty_formats="oneline short medium full email raw format:"

dequote ()
{
    eval echo "$1" 2> /dev/null
}
_ssh ()
{
    local cur prev configfile;
    local -a config;
    COMPREPLY=();
    ...
}
__git_complete_file ()
{
    __git_complete_revlist_file
}
\end{lstlisting}}

Our goal is to recognize only procedure names (along with the optional braces) and ignore key-value pairs as well as function bodies. The program is expected to print the names of the functions one per line on the \emph{standard output} stream. If we were to execute our program with the input shown above, we would expect the following output:

{\setstretch{1.3}\lstset{language=bash, numbers=none,
    basicstyle=\ttfamily\small,
    showstringspaces=false,
    backgroundcolor=\color{gray}}
\begin{lstlisting}
dequote ()
_ssh ()
__git_complete_file ()
\end{lstlisting}}

\section{The Program}
In this section we will take a close look at a Python program that appears to meet the stated requirements. We will rely on informal reasoning to satisfy ourselves that the program indeed works in most cases and that there are no glaring logical errors.

Let us begin with the trivial definition of two helper functions. The \texttt{block\_begin} function checks if \emph{line} (argument) constitutes an open curly brace. Similarly, \texttt{block\_end} function checks for a closing curly brace. Taken together these functions will be used to recognize the beginning and end of a statement block.

\lstset{language=Python, numbers=left,
    basicstyle=\ttfamily\small, 
    keywordstyle=\color{keywords},
    identifierstyle=\color{black},
    procnamekeys={def},
    backgroundcolor=\color{background}}
\lstset{language=Python,
    numbers=left,
    basicstyle=\ttfamily\small, 
    keywordstyle=\color{keywords},
    commentstyle=\color{comments},
    backgroundcolor=\color{background},
    stringstyle=\color{red},
    identifierstyle=\color{black},
    procnamekeys={def}}	
\noindent\begin{lstlisting}
def block_begin(line): return line == '{\n'
def block_end(line):   return line == '}\n'
\end{lstlisting}

Let us now turn our attention to \texttt{collect\_fun\_names} that teases out procedure names by recognizing procedure definitions in the input text. The \texttt{src} argument of \texttt{collect\_fun\_names} is a Python file object representing the external text file. This function returns a list of procedure names found in the input. 

The working of \texttt{collect\_fun\_names} is straightforward. It sets off looking for the beginning of a statement block - an open-curly bracket on a line by itself. When it detects one, it looks for the matching close-curly bracket appearing on an independent line. Since a procedure name precedes the statement block, \texttt{collect\_fun\_names} stores the contents of the previous line on detecting the the beginning of a potential statement-block. The identifier \texttt{prev\_line} in the listing below serves this purpose. 

\noindent\begin{lstlisting}
def collect_proc_names(src):
  proc_names = []
  prev_line = None

  for line in src:
    if block_begin(line):
      pn = prev_line
      for line in src:
        if block_end(line):
          proc_names.append(pn)
          break
    else:
      prev_line = line

  return proc_names
\end{lstlisting}

In the program listing above, line 1 creates an empty list that would contain, when the program terminates, names of procedures found in the input. The \textit{for} loop on line 5 starts reading each line from the input stream \texttt{src} looking for statement blocks. Line 7 stores a potential procedure name in \texttt{pn}. The code on lines 8, 9 and 10 look for the end of a statement block, and if found, insert the name of the procedure into the list of procedure names (\texttt{proc\_names}).

\subsection{The semantics of the \textit{for} statement}
At this point we should draw the attention of the reader to an important aspect of Python programming language. The nested iteration in the listing above, represented by two \textit{for} statements on lines 5 and 8, use the same identifier - \texttt{line} - for binding successive lines from the input. This is perfectly valid in Python because the identifier \texttt{line} gets bound \textit{each time} through the iteration. This is unlike most other imperative programming languages where either it is wrong to mutate the value of the loop index or it will adversely affect iteration. In the following discussion, we will pay some more attention this particular aspect because it is an important detail for understanding our program. At an altogether different level, this discussion will highlight a serious flaw with the definition of iterator interface in Python.

Iteration over built-in sequence types and user-defined containers is defined in terms of two key ideas: an \textit{iterable} and an \textit{iterator}. Iterables are types that implement \texttt{\_\_iter\_\_()} method to yield an iterator object. Iterators implement an interface with two methods: \texttt{\_\_next\_\_()} and  \texttt{\_\_iter\_\_()}. The former returns the next item from the container. It raises the StopIteration exception when no further elements are available. The \texttt{\_\_iter\_\_()} method of an iterator object is required to return a reference to itself. This makes it possible to use containers and iterators with the \textit{for} and \textit{in} statements.

In Python the \textit{for} statement is used to iterate over the elements of a sequence such as a string, tuple, list or any \textit{iterable} object. In order to understand the semantics of \textit{for} statement we shall take a look at its syntax using the BNF notation. For brevity and to focus only on the essentials, we show only a fragment of the actual rule from the official Python language documentation while eliding the details:

{\begin{verbatim}
for_stmt ::=  "for" target_list "in" expression_list ":" suite
              ["else" ":" suite]
expression_list ::=  expression ( "," expression )* [","]
target_list     ::=  target ("," target)* [","]
target          ::=  identifier
                 | ...
\end{verbatim}}

The symbols enclosed within a pair of double-quotes represent either keywords or exact lexical symbols. Symbols enclosed within a pair of square brackets are optional elements, and $\ast$ represents for zero or more repetitions of a grammar symbol.

The execution of the \textit{for} statement begins with the evaluation of \texttt{expression\_list}. The \texttt{expression\_list} is evaluated only once and this it is expected to yield an \textit{iterable} object, which is used in turn to obtain an \textit{iterator} instance. This iterator is further used to obtain successive values from the underlying container, and each value is bound to the identifier in the \texttt{targe\_list}. The iterator is not directly visible in most cases, with the program accessing only the value returned by the iterator. In other words, the \textit{for} statement effectively hides the iterator interface behind syntactic sugar!

Referring back to our program, it is important to note that the two \texttt{for} loops found on lines 5 and 8 share a common iterator representing shared offsets within the underlying physical file stream. This is in contrast to the iterator interface exposed by most sequence types in Python. We shall return to this topic later in this article.

%\href{http://docs.python.org/2/reference/compound_stmts.html#the-for-statement}{\texttt{for} loop}

\section{Assigning Meaning to the Program}
What do we mean by assigning meaning to a program?

We can imagine the meaning of a program to be various invariants and logical relations that hold among state variables of a program as the execution evolves over a large state space. This attitude leads us to one particular way of understanding how a program computes what it claims to compute. The essential idea would be to develop programs with a clear understanding of the initial conditions of the program, the structure of the expected outcome, and the rules that guide the transformation of values of various variables that constitute the state of an executing program at any given point in time.

Ideally, we would like the program design to be guided by this principle. WHen it is not possible for some reason, we can use this very idea to figure out precisely how the execution of a program proceeds in its state space. With a precise knowledge of the requirements, we may attempt to find out logical relationships among state variables and states of an executing program. And this is what we wish to show in the following subsections. 

\subsection{The first few cycles}
In the card shown below, we have highlighted two sections of the program. Our idea is to informally develop a few meaningful logical relations among the variables of this program.

\vspace*{10pt}\noindent\begin{tabular}{@{}ll}
{\lstset{language=Python, basicstyle=\ttfamily\small, backgroundcolor=\color{gray}}
\begin{lstlisting}
def collect_fun_names(src):
  proc_names = []
  prev_line = None
\end{lstlisting}}
&\\
{
\begin{lstlisting}[firstnumber=last, backgroundcolor=\color{lightorange}]
  for line in src:
    if open_curly(line):
\end{lstlisting}}
& $ 0 \le i < |src| \,\wedge\, src[i] \ne \mathtt{'\{'}$\\
{
\begin{lstlisting}[firstnumber=last, backgroundcolor=\color{gray}]
      pn = prev_line
      for line in src:
        if close_curly(line):
          proc_names.append(pn)
          break
\end{lstlisting}}
& $$\\
{
\begin{lstlisting}[firstnumber=last, backgroundcolor=\color{lightorange}]
    else:
\end{lstlisting}}
& $ i = 0 \Rightarrow prev\_line = \bot$\vspace*{-0.8pt}\\
{
\begin{lstlisting}[firstnumber=last, backgroundcolor=\color{lightorange}]
      prev_line = line
\end{lstlisting}}
& $ 0 < i \Rightarrow (prev\_line \ne \bot)$\\
{
\begin{lstlisting}[firstnumber=last]
  return fun_names
\end{lstlisting}}
&\\
\end{tabular}\vspace*{0.3mm}\\

What will be the state of the program variables when a open curly bracket marks the beginning of a statement block? We see this condition holds when the program reaches the line 6 in the program text. The logical relation among the values of the state variables is shown in the card below:\vspace*{0.2mm}\\

%
% --------------------- THE SECOND CYCLE BEGINS HERE ------------
%
\vspace*{12pt}\noindent\begin{tabular}{@{}ll}
{\lstset{language=Python, basicstyle=\ttfamily\small, backgroundcolor=\color{gray}}
\begin{lstlisting}
def collect_fun_names(src):
  proc_names = []
  prev_line = None
\end{lstlisting}}&\\
{
\begin{lstlisting}[firstnumber=last, backgroundcolor=\color{lightorange}]
  for line in src:
\end{lstlisting}}
& $ 0 < i < |src| \Rightarrow prev\_line \ne \bot $\\
{
\begin{lstlisting}[firstnumber=last, backgroundcolor=\color{lightorange}]
  if open_curly(line):
      pn = prev_line
\end{lstlisting}}
&
$prev\_line = src[i - 1] \,\wedge\, src[i] = \mathtt{'\{'}$\\
{
\begin{lstlisting}[firstnumber=last, backgroundcolor=\color{gray}]
      for line in src:
        if close_curly(line):
          proc_names.append(pn)
          break
\end{lstlisting}}
%& $line = src[i]\,\wedge\,i = 0 \Rightarrow prev\_line = \bot$\\
&\\
{
\begin{lstlisting}[firstnumber=last, backgroundcolor=\color{lightbrown}]
    else:
      prev_line = line
\end{lstlisting}}
&$ i = 0 \Rightarrow (prev\_line = \bot \,\wedge\, line = src[0])$\\
{
\begin{lstlisting}[firstnumber=last]
  return fun_names
\end{lstlisting}}
&\\
\end{tabular}\\

%
% --------------------- THE SECOND CYCLE ENDS HERE ------------
%




%
% --------------------- THE THiRd CYCLE BEGINS HERE ------------
%

\vspace*{12pt}\noindent\begin{tabular}{@{}ll}
{\lstset{language=Python, basicstyle=\ttfamily\small, backgroundcolor=\color{gray}}
\begin{lstlisting}
def collect_fun_names(src):
  proc_names = []
  prev_line = None
\end{lstlisting}}&\\
{
\begin{lstlisting}[firstnumber=last, backgroundcolor=\color{lightorange}]
  for line in src:
\end{lstlisting}}
& $ 0 < i < |src| \Rightarrow prev\_line \ne \bot $\\
{
\begin{lstlisting}[firstnumber=last, backgroundcolor=\color{lightorange}]
  if open_curly(line):
      pn = prev_line
\end{lstlisting}}
&
$prev\_line = src[i - 1] \,\wedge\, src[i] = \mathtt{'\{'}$\\
{
\begin{lstlisting}[firstnumber=last, backgroundcolor=\color{gray}]
      for line in src:
\end{lstlisting}}
&\\
{
\begin{lstlisting}[firstnumber=last, backgroundcolor=\color{lightorange}]
        if close_curly(line):
          proc_names.append(pn)
          break
\end{lstlisting}}
& $ 1 < i < |src| \Rightarrow  (0 \le j < i \,\wedge\, src[j] =  \mathtt{'\{'})$\\
{
\begin{lstlisting}[firstnumber=last, backgroundcolor=\color{lightbrown}]
    else:
      prev_line = line
\end{lstlisting}}
&$ i = 0 \Rightarrow (prev\_line = \bot \,\wedge\, line = src[0])$\\
{
\begin{lstlisting}[firstnumber=last]
  return fun_names
\end{lstlisting}}
&\\
\end{tabular}\\



%
% --------------------- THE THird CYCLE ENDS HERE ------------
%


\subsection{And then we find a bug}
\noindent\hspace*{-0.5em}\begin{tabular}{@{}ll@{}}
{\noindent\lstset{language=Python, basicstyle=\ttfamily\small, numbers=left}
\noindent\begin{lstlisting}
def collect_fun_names(src):
  proc_names = []
\end{lstlisting}}
&\\

{\noindent\lstset{language=Python, numbers=left, backgroundcolor=\color{lightgreen}}
\begin{lstlisting}[firstnumber=3]
  prev_line = None
\end{lstlisting}}
&$prev\_line = \bot$\\

{\noindent\lstset{numbers=left, backgroundcolor=\color{lightgreen}}
\noindent\begin{lstlisting}[firstnumber=last]
  for line in src:
\end{lstlisting}}
& $(|src| = N) \wedge\,(0 \le i < N) $\\

\noindent\lstset{backgroundcolor=\color{lightgreen}}
\noindent{\begin{lstlisting}[firstnumber=last]
    if open_curly(line):
\end{lstlisting}}
& $line = src[i]\,\wedge\,i = 0 \Rightarrow prev\_line = \bot$\\

\noindent\lstset{backgroundcolor=\color{lightgreen}}
{\begin{lstlisting}[firstnumber=last]
      pn = prev_line
\end{lstlisting}}
&$line = ``\{" \,\wedge\,i = 0 \Rightarrow proc\_name = \bot $\\

\lstset{backgroundcolor=\color{lightgreen}}
{\begin{lstlisting}[firstnumber=last]
      for line in src:
        if close_curly(line):
\end{lstlisting}}
& $(i+1) \le j < N \wedge line = src[j]$\\
\lstset{backgroundcolor=\color{lightgreen}}
{\begin{lstlisting}[firstnumber=last]
          proc_names.append(pn)
\end{lstlisting}}
&$src[i] = ``\{"\,\wedge\,src[j] = ``\}"\,\wedge\,(i \le j < N)$\\
\lstset{backgroundcolor=\color{lightgreen}}
{\begin{lstlisting}[firstnumber=last]
          break
\end{lstlisting}}
& $(i = 0) \Rightarrow \bot \in proc\_names $\\

{\noindent\hspace*{0.35em}\begin{lstlisting}[numbers=left, firstnumber=last]
    else:
      prev_line = line
\end{lstlisting}}
&\\
{\noindent\hspace*{0.35em}\begin{lstlisting}[firstnumber=last]
  return fun_names
\end{lstlisting}}

\end{tabular}
\end{document}

