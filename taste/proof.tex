\documentclass[10pt, a4paper]{article}
\usepackage{color}
\usepackage[procnames]{listings}
\usepackage[draft]{todonotes}   % notes showed
\usepackage{setspace}

\addtolength{\oddsidemargin}{-.4in}
\addtolength{\evensidemargin}{-.4in}
\addtolength{\topmargin}{0in}
\addtolength{\textwidth}{0.8in}
\addtolength{\textheight}{.6in}

\renewcommand{\baselinestretch}{1.3}

\begin{document}
\title{An Exercise in Assigning Meaning to a Python Program}
\author{M. Devi Prasad\vspace*{1.5mm}\\\texttt{dp@vlabs.ac.in}\\\texttt{deviprasad.m@iiit.ac.in},}
\date{}
\maketitle

\definecolor{keywords}{RGB}{0, 0, 255}
\definecolor{comments}{RGB}{0, 0, 113}
\definecolor{red}{RGB}{160, 0, 0}
\definecolor{green}{RGB}{0, 150, 0}
\definecolor{lightgreen}{RGB}{220, 230, 140}
\definecolor{black}{RGB}{0, 0, 0}
\definecolor{background}{RGB}{210, 210, 210}
\definecolor{gray}{RGB}{230, 230, 230}

\section{Background}
In this short article, we show the application of simple and interesting ideas from Computing Science to understand the behavior of a Python program. The motivation is to apply a small number of ``pure" ideas of Computing Science to the ``impure" settings of real world (Python) programs with the hope that this exercise yields useful insights.

In what follows, we employ basic ideas of first-order logic to track the execution state of our Python program. In so doing, we will discover a bug in our program. Further, we will clarify one aspect of Python's iterator mechanism that appears to provide a stream-like interface to external files. Our attempt to express, in logical terms, the meaning of file iterators reveals that all iterators of an underlying file share the same state. We have found that this invariably surprises programmers whose intuitions are shaped by iterators for in-built sequence types of Python. While passing we would like to mention that the official documentation of Python language (and its libraries) do not state this fact.

The primary audience of this article includes students of ITWS2 course to whom we teach two ``scripting" languages - Python and JavaScript - to build 2D games. Our goal is to impress the fact that the techniques used in this exercise can be easily practiced by novices, and with a little practice, can be used as an effective tool to guide the creation of test cases. It is also useful to recognize that these very techniques may be used to formulate program assertions.  

%In our opinion, impurities and difficulties in reasoning about the behavior of a program arise because of not-so-well-structured control flow, assignment statements, file I/O and assumptions about the well-formedness of the inputs. 

%Our goal is not to be scholarly and pedantic. On the contrary, our goal is to develop an appreciation for practicing some form of rigor, albeit in slightly diluted, and to discover for oneself that one can develop comprehensive test cases and assertions as an \emph{after thought}, having written the program and after having bitten by an embarrassing defect! Even if we do not succeed in designing correct programs ground up, we could take solace in the fact that we could apply simple ideas to develop good test cases and insert educated assertion within our programs. We would like our students to derive intellectual satisfaction in using semi-formal reasoning skills to increase their own confidence in the software they would eventually build!

\section{Context}
We intend to assign meaning to a Python program that parses text files generated by running the \texttt{set} command under Linux (``bash") shell. Therefore, it is essential to understand the structure of the input to our program. But first, we shall see the actual command and the input text creation step:
{\setstretch{1.3}\lstset{language=bash, numbers=none,
    basicstyle=\ttfamily\small,
    showstringspaces=false,
    backgroundcolor=\color{gray}}
\begin{lstlisting}
$ set > env.txt
\end{lstlisting}}

\noindent Note that the output of the \texttt{set} command is redirected to a text file named \texttt{env.txt}. When the command executes successfully, this file contains a series of key-value pairs representing the environment variables active in the context of the currently running shell. Each line in the text file contains one key-value pair. 

In addition to key-value pairs, the text file contains a series of function definitions. A function definition consists of a name followed by an optional pair of braces (``(" and ``)"), followed by a block of statements. A statement block is enclosed within a pair of matching curly brackets (``\{" \ and \ ``\}"). It contains a sequence of statements (or shell commands). The open and close curly brackets appear on separate lines with no other lexical token either preceding them or following them (other than the ``invisible" newline character!). Here is a sample definition to help us visualize the typical form of a function:

{\setstretch{1.3}\lstset{language=bash, numbers=none,
    basicstyle=\ttfamily\small,
    showstringspaces=false,
    backgroundcolor=\color{background}}
\begin{lstlisting}
BASH=/bin/bash
BASH_ARGC=()
CHROME_DEVEL_SANDBOX=/usr/local/sbin/chrome-devel-sandbox
COLORTERM=gnome-terminal
COLUMNS=76
__git_log_pretty_formats="oneline short medium full email raw format:"

dequote ()
{
    eval echo "$1" 2> /dev/null
}
_ssh ()
{
    local cur prev configfile;
    local -a config;
    COMPREPLY=();
    ...
}
__git_complete_file ()
{
    __git_complete_revlist_file
}
\end{lstlisting}}

Our goal is to recognize only function names (along with the optional braces) and ignore key-value pairs as well as function bodies. The program is expected to output names of the functions one per line. If we were to execute our program with the input shown above, we would expect the following listing in the output:

{\setstretch{1.3}\lstset{language=bash, numbers=none,
    basicstyle=\ttfamily\small,
    showstringspaces=false,
    backgroundcolor=\color{gray}}
\begin{lstlisting}
dequote ()
_ssh ()
__git_complete_file ()
\end{lstlisting}}

\section{The Program}
In this section we will take a closer look at a Python program that appears to meet our requirements mentioned in the previous section. Our intention is to rely on informal reasoning to quickly check that the program indeed works in most cases and that there are no glaring logical errors.

Let us begin with the trivial definition of two helper functions. The \texttt{block\_begin} function checks if \emph{line} (argument) contains a single open curly brace. Similarly, \texttt{block\_end} function checks for a closing curly brace.

\lstset{language=Python, numbers=left,
    basicstyle=\ttfamily\small, 
    keywordstyle=\color{keywords},
    identifierstyle=\color{black},
    procnamekeys={def},
    backgroundcolor=\color{background}}
\lstset{language=Python,
    numbers=left,
    basicstyle=\ttfamily\small, 
    keywordstyle=\color{keywords},
    commentstyle=\color{comments},
    backgroundcolor=\color{background},
    stringstyle=\color{red},
    identifierstyle=\color{black},
    procnamekeys={def}}	
\noindent
\begin{lstlisting}
def block_begin(line): return line == '{\n'
def block_end(line):   return line == '}\n'
\end{lstlisting}

Notice 

\begin{lstlisting}
def collect_fun_names(src):
  fun_names = []
  prev_line = None

  for line in src:
    if block_begin(line):
      fun_name = prev_line
      for line in src:
        if block_end(line):
          fun_names.append(fun_name)
          break
    else:
      prev_line = line

  return fun_names
\end{lstlisting}

\section{Assigning Meaning to the Program}
\noindent
\noindent\hspace*{-0.5em}\begin{tabular}{@{}ll@{}}
{\noindent\lstset{language=Python, basicstyle=\ttfamily\small, numbers=left}
\noindent\begin{lstlisting}
def collect_fun_names(src):
  fun_names = []
\end{lstlisting}}
&\\

{\noindent\lstset{language=Python, numbers=left, backgroundcolor=\color{lightgreen}}
\begin{lstlisting}[firstnumber=3]
  prev_line = None
\end{lstlisting}}
&$prev\_line = \bot$\\

{\noindent\lstset{numbers=left, backgroundcolor=\color{lightgreen}}
\noindent\begin{lstlisting}[firstnumber=last]
  for line in src:
\end{lstlisting}}
& $(|src| = N) \wedge\,(0 \le i < N) $\\

\noindent\lstset{backgroundcolor=\color{lightgreen}}
\noindent{\begin{lstlisting}[firstnumber=last]
    if open_curly(line):
\end{lstlisting}}
& $line = src[i]\,\wedge\,i = 0 \Rightarrow prev\_line = \bot$\\

\noindent\lstset{backgroundcolor=\color{lightgreen}}
{\begin{lstlisting}[firstnumber=last]
      fun_name = prev_line
\end{lstlisting}}
&$line = ``\{" \,\wedge\,i = 0 \Rightarrow fun\_name = \bot $\\

\lstset{backgroundcolor=\color{lightgreen}}
{\begin{lstlisting}[firstnumber=last]
      for line in src:
        if close_curly(line):
\end{lstlisting}}
& $(i+1) \le j < N \wedge line = src[j]$\\
\lstset{backgroundcolor=\color{lightgreen}}
{\begin{lstlisting}[firstnumber=last]
          fun_names.append(fun_name)
\end{lstlisting}}
&$src[i] = ``\{"\,\wedge\,src[j] = ``\}"\,\wedge\,(i \le j < N)$\\
\lstset{backgroundcolor=\color{lightgreen}}
{\begin{lstlisting}[firstnumber=last]
          break
\end{lstlisting}}
& $(i = 0) \Rightarrow \bot \in fun\_names $\\

{\noindent\hspace*{0.35em}\begin{lstlisting}[numbers=left, firstnumber=last]
    else:
      prev_line = line
\end{lstlisting}}
&\\
{\noindent\hspace*{0.35em}\begin{lstlisting}[firstnumber=last]
  return fun_names
\end{lstlisting}}

\end{tabular}
\end{document}

